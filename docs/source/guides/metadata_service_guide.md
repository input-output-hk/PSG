# The Metadata Service API

This document describes using the service as an API. Working knowledge of gRpc is assumed.

## Service API

This is a partial listing of the MetadataService (v0.2)
```
service MetadataService {
   rpc SubmitMetadata(SubmitMetadataRequest) returns (stream SubmitMetadataResponse);
   rpc ListMetadata(ListMetadataRequest) returns (stream ListMetadataResponse);
}

message SubmitMetadataRequest {
  oneof options {
    string metadata = 1;
    string tx_id = 2; //For restarts, will start polling
  }
  int32 until_depth = 3;
  iog.psg.service.common.CredentialsMessage credentials = 4;
}

message SubmitMetadataResponse {
  oneof result {
    string problem = 1;
    TxStatus tx_status = 2;
  }
}
```

There are two functions, one for submitting metadata or checking on an already submitted metadata transaction and a second listing function.

Both methods provide a *stream* of responses.

### Submit Metadata

To submit metadata the caller provides 

  - the depth 
    
This is the number of blocks the caller wants the metadata transaction buried under. 
If the caller specifies a depth of 1 block there is always the chance the blockchain will reorganise itself and remove the transaction, 
a depth of 100 means that possibility is vanishingly small, but the call will take longer. 

  - the credentials

These are the credentials generated by the PSG Services web application after the user has created a "log in" and paid for use of the services.

**Note**: - valid credentials are not necessary when using the testnet 
  - the metadata 

Provide the metadata as a string in JSON format, but conforming to the schema described
[here](https://input-output-hk.github.io/cardano-wallet/api/edge/#operation/postTransactionFee)

  - OR the transaction id

The first result in the stream of results returned by the call will contain the transaction id (`tx_id`). In the case where the call is 
interrupted  it can be restarted by calling "SubmitMetadata" again but providing the transaction id instead of the metadata. 

The result will be a stream of responses; these responses are checked for status, first to make sure the request has a state 'IN_LEDGER'
and finally, to indicate the transaction has been 'buried' under the requisite number of blocks.

In the case of a problem, that problem is described in the `problem` field of the response.`


### List Metadata

List all metadata transactions between the dates given.  

**Note**: The list contains transactions from **all** users. In order to get transactions for a particular user - you need to filter a list by `metadata` or `transactionId`. 

**Note**: the dates are optional and when not provided, all metadata transactions are returned.

**Note**: if a transaction has no metadata, it will not be listed by this call.

**Note**: on the very rare occasions where the internal service configuration drastically changes transactions associated with a clientId may not be returned. 
Client applications that have a critical long term dependency on remembering the ids of the transactions they posted are advised to make an independent record of the transaction id.

# Client SDK API - How to

## maven dependency
```xml
<dependency>
     <groupId>solutions.iog</groupId>
     <artifactId>metadata-client_2.13</artifactId>
    <version>0.0.3</version>
</dependency>
```
### Create the api
```java
    MetadataAsync metadataApi = new MetadataAsync("API_TOKEN", "CLIENT_ID", "localhost", 2000);
```

### Submit the Metadata to Blockchain
* Replace `metadata` with string value that represents your metadata
```java
    public CompletionStage<String> submitMetadata() {
        String metadata= "MyMetadata";
        CompletableFuture<String> completableFuture = new CompletableFuture();
        metadataApi.submitMetadata(metadata, streamObserver(completableFuture, r -> r.getTxStatus().toString()));
        return completableFuture;

    }
```    

### Get the Metadata
* Replace `txId` with the Id Transaction
```java
    public CompletionStage<String> transactionMetadata() {
        String txHash = "234234acb";
        CompletableFuture<String> completableFuture = new CompletableFuture();
        metadataApi.transactionMetadata(txHash, streamObserver(completableFuture, r -> r.getMetadata().toString()));
        return completableFuture;

    }
```

### List the Metadata transaction statuses
* Replace `startAt` with timestamp from which metadata should be listed
* Replace `endAt` with timestamp to which metadata should be listed
```java
    public CompletionStage<String> listMetadata() {
        Timestamp startAt = Timestamp.of(100000000, 0);
        Timestamp endAt = Timestamp.of(200000000, 0);
        CompletableFuture<String> completableFuture = new CompletableFuture();
        metadataApi.listMetadata(startAt, endAt, streamObserver(completableFuture, r -> r.getTxStatus().toString()));
        return completableFuture;

    }
```

##### The Observer
The example of observer. This might be used in the example above. It gets the events about the transaction sent details.
```java
    private <V> StreamObserver<V> streamObserver(CompletableFuture<String> completableFuture,
                                                 Function<V, String> converter) {
        return new StreamObserver<V>() {
            List<String> buffer = new ArrayList();

            @Override
            public void onNext(V res) {
                buffer.add(converter.apply(res));
            }

            @Override
            public void onError(Throwable throwable) {
                buffer.add(throwable.toString());
            }

            @Override
            public void onCompleted() {
                String res = buffer
                        .stream()
                        .collect(Collectors.joining("\n"));
                completableFuture.complete(res);
            }
        };
    }
```










